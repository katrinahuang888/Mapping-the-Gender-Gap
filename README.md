# Mapping-the-Gender-Gap
  **Introduction:** To analyze the slowing fight for women’s rights in the United States, our group decided to run an experiment on the set of 50 Hollywood movies and constructed our own quantitative test (inspired by the Bechdel Test) to measure the gender imbalance in the Hollywood industry.
  **Method:** Our group chose to use the AdjListsGraph (part of the javafoundations package) as our HollywoodGraph, as some methods we wanted to create were previously defined (i.e. addVertex(), addEdge(), saveToTGF()). To pursue object oriented programming and store all properties contingent to our object, we wrote a HollywoodNode parent class (holding ‘name’ property) and two child classes, Actor and Movie (holding all other properties necessary) to create our graph, adding edges and vertices to our graph when appropriate. 
  When visualizing our HollywoodGraph, we noticed our graph was connected (no disconnected nodes), undirected (vertices are connected by edges, pairs of arcs that go both directions), and bipartite (two-colorable). When considering the next task, we thought about the possibility to show the degrees of separation among the actors by utilizing a Breadth First Search (BFS).
  For Task 2.0-2.1, we used hashtables to keep track of which actors were in which movies and vice versa. This is our ideal data structure with a time complexity of O(1) and it is dynamic, allowing us to continuously add to the table without needing to expand capacity.
  In order to find the degrees of separation given two strings for the actor name, while at first we considered a Depth First Search, we ultimately decided to implement a BFS, since our graph is bipartite and each alternating layer are either movies or actors, and hence it would be more efficient for us to find our target actor in that way. We created two helper methods, getActorObjects() and getMovieObjects() which retrieves the Actor object or Movie object, respectively, through a basic manipulation of our hashtables. Following the principle of a BFS, from our beginning Actor, we traverse the graph layer by layer, marking the vertex as visited and continuing onto the next layer until we reach our target Actor. Eventually, the method prints a list of movies and returns the size of that list–the degree of separation between the origin and target Actors–by keeping track of what level the graph is on, if we imagined our graph as a tree and our origin Actor as the root. This method has a time complexity of either O(n) or O(n^2).
  For the final subtask, we created a new Bechdel test that examines gender inequality in movies by testing if each movie has x female characters who are leading and under a given billing threshold y, where x and y are formal parameters for the user to input. Using a for loop to search through an iterator that contains a list of characters to see if they meet our test criteria, we stored our results in a stack due to its dynamic structure. The time complexity of the method is O(n^2), efficient given our complex test goal.
  We have also come to realize that instance variables such as billing and character type are not contingent to the actor class but rather the movie class. If we had additional time, we would resolve this issue to make our implementation more accurate.
  **Conclusion:** Our group gained many valuable technical skills throughout the course of working on this project: from designing large-scale object-oriented code to building a graph representation, implementing graph traversals, creating algorithms for analyzing graphs, and applying this knowledge to real-world data. We also gained insight into how different data structures can ultimately impact our code’s design or overall efficiency. We discovered this while attempting to find the degrees of separation between two given actors, A1 and A2, and were forced to use multiple for loops, each with a time complexity of O(n), in order to return the correct path of movies that led us from A1 to A2. Above all, we learned that teamwork, communication, version control, and remaining cognizant of software engineering principles were the keys to a successful project.
  We believed our test to be a reasonable and meaningful one as it brings awareness about gender representation and portrayal in the film industry and creates a simple and applicable measure for various media, sparking further analyses about the quality and depth of female characters. Like the original Bechdel test, our curated Bechdel test also fails most of the 50 Hollywood casts that were provided. We hope that the results generated by our Bechdel test will impact how film watchers see the film industry, and push film producers to address these gender disparities by striving for better representation.
  **Collaboration:** Developing our own version of the Bechdel analysis metric was no one-person show; our group brainstormed different approaches, debated their time complexity, and ultimately refined our algorithm through feedback from professors and constant testing of code. All members of our group shared the same goals, and kept an open mind toward learning from each other and our own individual mistakes. Aiming to write code in an efficient, design-focused manner, we each shouldered and alternated roles: (1) the driver, who wrote and edited the code, (2) the navigator, who dictated code to the writer (referencing class resources or Java API), and (3) the researcher, who looked through class resources and reviewed our code for solutions to our problems.
  While writing code for our project, our group ran into many problems that left us stumped, spending hours trying to solve another problem with a level of complexity seemingly even more difficult than the last. Even during these times – when morale was low, tensions were high, and we were all exhausted – everyone remained level-headed and conflict-resolute. Ultimately, this collaborative process led to a meaningful metric, our new Bechdel test, while also strengthening our understanding of a broad range of computer science principles.
